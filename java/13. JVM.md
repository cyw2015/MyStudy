1. 当Java虚拟机遇到new 指令时。先去检查指令的参数是否能够在常量池中定位到一个类得符号引用，
2. 检查这个符号引用代表的类是否已被加载，解析和初始化过（类加载过程）
3. 类加载检查通过后，为新生对象分配内存，**对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来**
4. 并发分配对象，策略，1.同步 - CAS方式 2.本地线程分配缓冲区 TLAB(Thread Local Allocation Buffer) 
5. 内存分配后,初始化零值, 对象头设置
6. 执行构造函数

## 对象内存布局  
HotSpot虚拟机
对象在堆内存中的存储布局分为三个部分：对象头(Header),实例数据(Instance Data)和对其填充（Padding).  
对象头包括两类：
* 存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID,偏向时间戳等。这部分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特和64个比特，官方称为：Mark Word
* 类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例，如果对象是一个Java数组， 那在对象头中还必须有一块用于记录数组长度的数据， 因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小， 但是如果数组的长度是不确定的， 将无法通过元数据中的信息推断出数组的大小。  

实例数据：
对象所属类中定义的各种类型的字段内容，无论是从父类继承下来的， 还是在子类中定义的字段都必须记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数） 和字段在Java源码中定义顺序的影响。默认分配顺序为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops（Ordinary Object Pointers， OOPs） ，在父类中定义的变量会出现在子类之前

对齐填充：
不是必然存在，占位用，HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍。对象头刚好是8字节的倍数，如果对象实例数据没有对其，则通过对其填充补齐

## 对象的访问定位：
* 句柄
* 直接指针